<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° Volatility Scalper - Learn to Auto-Trade</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 25px;
            background: rgba(255,255,255,0.05);
            border-radius: 16px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        h1 {
            font-size: 1.6em;
            background: linear-gradient(135deg, #ff6b6b, #ffd93d, #6bcb77);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .mode-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
        }

        .mode-indicator.manual {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
        }

        .mode-indicator.learning {
            background: rgba(255, 217, 61, 0.2);
            color: #ffd93d;
        }

        .mode-indicator.auto {
            background: rgba(107, 203, 119, 0.2);
            color: #6bcb77;
        }

        /* Stats Bar */
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .stat-box .label { font-size: 0.8em; color: #888; }
        .stat-box .value { font-size: 1.4em; font-weight: bold; margin-top: 5px; }
        .stat-box .value.green { color: #6bcb77; }
        .stat-box .value.red { color: #ff6b6b; }
        .stat-box .value.yellow { color: #ffd93d; }

        /* Main Trading Area */
        .trading-area {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }

        @media (max-width: 900px) {
            .trading-area { grid-template-columns: 1fr; }
        }

        /* Volatility Scanner */
        .scanner {
            background: rgba(255,255,255,0.05);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .scanner h2 {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .scanner-grid {
            display: grid;
            gap: 10px;
        }

        .scan-item {
            display: grid;
            grid-template-columns: 80px 100px 1fr 100px 80px;
            align-items: center;
            gap: 10px;
            padding: 12px 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .scan-item:hover {
            background: rgba(255,255,255,0.05);
        }

        .scan-item.hot {
            border-color: #ff6b6b;
            animation: pulse-border 1s infinite;
        }

        .scan-item.spiking {
            border-color: #ffd93d;
            background: rgba(255, 217, 61, 0.1);
        }

        .scan-item.extreme {
            border-color: #ff3333;
            background: rgba(255, 51, 51, 0.15);
            animation: pulse-extreme 0.8s infinite;
        }

        .scan-item.entry-signal {
            border-color: #00ff88;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 212, 255, 0.2));
            animation: pulse-entry 0.5s infinite;
            transform: scale(1.02);
        }

        @keyframes pulse-border {
            0%, 100% { box-shadow: 0 0 5px #ff6b6b; }
            50% { box-shadow: 0 0 20px #ff6b6b; }
        }

        @keyframes pulse-extreme {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 51, 51, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 51, 51, 0.8); }
        }

        @keyframes pulse-entry {
            0%, 100% { box-shadow: 0 0 15px rgba(0, 255, 136, 0.6); transform: scale(1.02); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 136, 0.9); transform: scale(1.03); }
        }

        .signal-badge {
            display: inline-block;
            padding: 2px 8px;
            background: linear-gradient(135deg, #00ff88, #00d4ff);
            color: #000;
            border-radius: 10px;
            font-size: 0.7em;
            font-weight: bold;
            margin-left: 8px;
            animation: badge-glow 1s infinite;
        }

        .extreme-badge {
            display: inline-block;
            padding: 2px 8px;
            background: linear-gradient(135deg, #ff3333, #ff6b6b);
            color: #fff;
            border-radius: 10px;
            font-size: 0.7em;
            font-weight: bold;
            margin-left: 8px;
        }

        @keyframes badge-glow {
            0%, 100% { box-shadow: 0 0 5px #00ff88; }
            50% { box-shadow: 0 0 15px #00ff88; }
        }

        .scan-item .symbol { font-weight: bold; font-size: 1.1em; display: flex; align-items: center; }
        .scan-item .price { font-family: monospace; }
        
        .volatility-bar {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .volatility-fill {
            height: 100%;
            transition: width 0.3s, background 0.3s;
        }

        .volatility-fill.low { background: #6bcb77; }
        .volatility-fill.medium { background: #ffd93d; }
        .volatility-fill.high { background: #ff6b6b; }
        .volatility-fill.extreme { background: linear-gradient(90deg, #ff3333, #ff6b6b, #ffd93d); }

        .beta-value {
            font-family: monospace;
            font-weight: bold;
        }

        .trade-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .trade-btn.entry {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .trade-btn:hover { transform: scale(1.05); }

        /* Active Trade Panel */
        .active-trade {
            background: rgba(255,255,255,0.05);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.1);
            position: relative;
        }

        .active-trade.in-trade {
            border-color: #667eea;
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.3);
        }

        .trade-symbol {
            font-size: 2em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
        }

        .price-display {
            text-align: center;
            padding: 20px;
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            margin-bottom: 15px;
        }

        .current-price {
            font-size: 3em;
            font-weight: bold;
            font-family: monospace;
            transition: color 0.1s;
        }

        .current-price.profit { color: #6bcb77; text-shadow: 0 0 20px rgba(107, 203, 119, 0.5); }
        .current-price.loss { color: #ff6b6b; text-shadow: 0 0 20px rgba(255, 107, 107, 0.5); }

        .entry-info {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.9em;
            color: #888;
        }

        .pnl-display {
            text-align: center;
            font-size: 2em;
            font-weight: bold;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .pnl-display.profit { background: rgba(107, 203, 119, 0.2); color: #6bcb77; }
        .pnl-display.loss { background: rgba(255, 107, 107, 0.2); color: #ff6b6b; }

        /* Fee Breakdown */
        .fee-breakdown {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 0.85em;
        }

        .fee-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            color: #888;
        }

        .fee-row span:last-child {
            color: #ff6b6b;
            font-family: monospace;
        }

        .fee-row.total {
            border-top: 1px solid rgba(255,255,255,0.1);
            margin-top: 8px;
            padding-top: 8px;
            color: #ffd93d;
        }

        .fee-row.total span:last-child {
            color: #ffd93d;
            font-weight: bold;
        }

        .timer-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .timer-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.1s linear;
        }

        .sell-button {
            width: 100%;
            padding: 20px;
            font-size: 1.5em;
            font-weight: bold;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.1s;
            text-transform: uppercase;
        }

        .sell-button.ready {
            background: linear-gradient(135deg, #6bcb77, #4ade80);
            color: #000;
            animation: pulse-sell 0.5s infinite;
        }

        .sell-button.wait {
            background: rgba(255,255,255,0.1);
            color: #666;
            cursor: not-allowed;
        }

        .sell-button.loss-exit {
            background: linear-gradient(135deg, #ff6b6b, #ff4444);
            color: #fff;
            cursor: pointer;
        }

        .sell-button.loss-exit:hover {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        @keyframes pulse-sell {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .sell-button:active:not(.wait) {
            transform: scale(0.98);
        }

        /* Keyboard hint */
        .key-hint {
            text-align: center;
            margin-top: 10px;
            color: #666;
            font-size: 0.9em;
        }

        .key-hint kbd {
            background: rgba(255,255,255,0.1);
            padding: 4px 10px;
            border-radius: 4px;
            font-family: monospace;
        }

        /* Learning Progress */
        .learning-section {
            background: rgba(255,255,255,0.05);
            border-radius: 16px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .learning-section h3 {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .progress-bar {
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ffd93d, #6bcb77);
            transition: width 0.5s;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            font-weight: bold;
            font-size: 0.8em;
            color: #000;
        }

        .learning-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .learn-stat {
            text-align: center;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .learn-stat .num { font-size: 1.5em; font-weight: bold; }
        .learn-stat .lbl { font-size: 0.8em; color: #888; }

        /* Pattern Display */
        .patterns {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        .pattern-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 0.9em;
        }

        .pattern-item:last-child { border-bottom: none; }

        /* No trade state */
        .no-trade {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .no-trade h3 {
            font-size: 1.3em;
            margin-bottom: 10px;
            color: #888;
        }

        /* Auto-trade toggle */
        .auto-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            margin-top: 15px;
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: linear-gradient(135deg, #6bcb77, #4ade80);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(30px);
        }

        /* Connection */
        .connection {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
        }

        .conn-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff6b6b;
        }

        .conn-dot.connected { background: #6bcb77; }

        /* Trade History Mini */
        .history-mini {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            margin-bottom: 5px;
            font-size: 0.85em;
        }

        .history-item.win { border-left: 3px solid #6bcb77; }
        .history-item.loss { border-left: 3px solid #ff6b6b; }
        
        .test-mode-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .test-mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .test-mode-btn.running {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚ö° Volatility Scalper</h1>
            <div class="mode-indicator manual" id="mode-indicator">
                <span id="mode-icon">üëÜ</span>
                <span id="mode-text">Manual Mode</span>
            </div>
            <button class="test-mode-btn" id="test-mode-btn" onclick="toggleTestMode()">ü§ñ Start Auto-Test (25 trades)</button>
            <button class="test-mode-btn" onclick="forceTestTrade()" style="background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);">‚ö° Force 1 Trade Now</button>
            <div class="connection">
                <span class="conn-dot" id="conn-dot"></span>
                <span id="conn-text">Connecting...</span>
            </div>
        </header>

        <div class="stats-bar">
            <div class="stat-box">
                <div class="label">Balance</div>
                <div class="value" id="balance">$1,000.00</div>
            </div>
            <div class="stat-box">
                <div class="label">Session P&L</div>
                <div class="value green" id="session-pnl">$0.00</div>
            </div>
            <div class="stat-box">
                <div class="label">Win Rate</div>
                <div class="value" id="win-rate">0%</div>
            </div>
            <div class="stat-box">
                <div class="label">Avg Exit Time</div>
                <div class="value yellow" id="avg-exit">-</div>
            </div>
            <div class="stat-box">
                <div class="label">Trades</div>
                <div class="value" id="trade-count">0</div>
            </div>
            <div class="stat-box">
                <div class="label">AI Confidence</div>
                <div class="value" id="ai-confidence">0%</div>
            </div>
        </div>

        <div class="trading-area">
            <!-- Volatility Scanner -->
            <div class="scanner">
                <h2>üîç Volatility Scanner <span style="font-size:0.6em;color:#888">(Click HOT trades)</span></h2>
                <div class="scanner-grid" id="scanner-grid">
                    <div style="text-align:center;padding:40px;color:#666;">
                        Scanning for volatility spikes...
                    </div>
                </div>
            </div>

            <!-- Active Trade Panel -->
            <div class="active-trade" id="active-trade">
                <div class="no-trade" id="no-trade">
                    <h3>üéØ No Active Trade</h3>
                    <p>Click a <span style="color:#ff6b6b">HOT</span> or <span style="color:#ffd93d">SPIKING</span> market to enter</p>
                </div>
                
                <div id="trade-panel" style="display:none;">
                    <div class="trade-symbol" id="trade-symbol">BTC</div>
                    
                    <div class="price-display">
                        <div class="current-price" id="current-price">$0.00</div>
                        <div class="entry-info">
                            <span>Entry: <span id="entry-price">$0.00</span></span>
                            <span>Size: <span id="position-size">$100</span></span>
                        </div>
                    </div>
                    
                    <div class="pnl-display loss" id="pnl-display">$0.00</div>
                    
                    <!-- Fee Breakdown -->
                    <div class="fee-breakdown" id="fee-breakdown">
                        <div class="fee-row">
                            <span>Gross P&L:</span>
                            <span id="gross-pnl">$0.00</span>
                        </div>
                        <div class="fee-row">
                            <span>Trading Fees (0.035% √ó 2):</span>
                            <span id="fee-amount">-$0.07</span>
                        </div>
                        <div class="fee-row">
                            <span>Slippage (~0.02% √ó 2):</span>
                            <span id="slippage-amount">-$0.04</span>
                        </div>
                        <div class="fee-row">
                            <span>Spread (~0.01%):</span>
                            <span id="spread-amount">-$0.01</span>
                        </div>
                        <div class="fee-row">
                            <span>Gas:</span>
                            <span style="color:#6bcb77">$0.00 ‚úì</span>
                        </div>
                        <div class="fee-row total">
                            <span>Break-even needed:</span>
                            <span id="breakeven-pct">+0.12%</span>
                        </div>
                    </div>
                    
                    <div class="timer-bar">
                        <div class="timer-fill" id="timer-fill" style="width:100%"></div>
                    </div>
                    
                    <button class="sell-button wait" id="sell-button" disabled>
                        WAIT FOR PROFIT...
                    </button>
                    
                    <div class="key-hint">
                        Press <kbd>SPACE</kbd> to sell instantly
                    </div>
                </div>
            </div>
        </div>

        <!-- Learning Section -->
        <div class="learning-section">
            <h3>üß† AI Learning Progress</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="learning-progress" style="width:0%">0%</div>
            </div>
            <p id="learning-status" style="color:#888;font-size:0.9em;">
                Complete 20 trades to unlock auto-trading. AI learns your exit timing patterns.
            </p>
            
            <div class="learning-stats">
                <div class="learn-stat">
                    <div class="num" id="learn-trades">0/20</div>
                    <div class="lbl">Trades Needed</div>
                </div>
                <div class="learn-stat">
                    <div class="num" id="learn-pattern">-</div>
                    <div class="lbl">Best Exit %</div>
                </div>
                <div class="learn-stat">
                    <div class="num" id="learn-timing">-</div>
                    <div class="lbl">Avg Hold Time</div>
                </div>
            </div>

            <div class="auto-toggle" id="auto-toggle-section" style="display:none;">
                <span>Auto-Trade</span>
                <div class="toggle-switch" id="auto-toggle"></div>
                <span id="auto-status">OFF</span>
            </div>

            <div class="patterns" id="patterns-section">
                <strong>Learned Patterns:</strong>
                <div id="patterns-list">
                    <p style="color:#666;text-align:center;padding:10px;">
                        Not enough data yet. Keep trading!
                    </p>
                </div>
            </div>
        </div>

        <!-- Mini History -->
        <div class="learning-section">
            <h3>üìú Recent Trades</h3>
            <div class="history-mini" id="history-mini">
                <p style="color:#666;text-align:center;padding:20px;">No trades yet</p>
            </div>
        </div>
    </div>

    <script src="hyperliquid.js"></script>
    <script>
        // =============================================
        // STATE & CONFIG
        // =============================================
        const config = {
            tradeWindowSeconds: 120,  // 2 minutes - realistic for 0.3%+ moves
            positionSize: 100,    // Bigger size = costs are smaller % of trade
            
            // REALISTIC SCALPING THRESHOLDS
            // With 0.12% costs on $50, we need 0.15%+ moves to profit
            // Strategy: Mean reversion + momentum continuation
            minVolatilityForHot: 0.02,      // 2% shows activity
            minVolatilityForSpike: 0.05,    // 5% is tradeable  
            minVolatilityForExtreme: 0.10,  // 10%+ is high probability

            // Momentum thresholds
            minMomentumForEntry: 0.035,     // Need price moving in a direction (lowered)
            
            tradesForAutoUnlock: 20,
            pollingRate: 50, // Much faster updates (50ms instead of 100ms)
            
            // ========================================
            // EXACT HYPERLIQUID FEES (Real wallet costs)
            // ========================================
            takerFeePercent: 0.035,
            makerFeePercent: 0.01,
            gasFeeUSD: 0,
            slippagePercent: 0.02,
            spreadPercent: 0.01,
            fundingRatePercent: 0.01
        };
        
        // Calculate total round-trip cost
        function calculateTradingCosts(positionSize, isMarketOrder = true) {
            const feeRate = isMarketOrder ? config.takerFeePercent : config.makerFeePercent;
            
            // Entry costs
            const entryFee = (feeRate / 100) * positionSize;
            const entrySlippage = (config.slippagePercent / 100) * positionSize;
            const entrySpread = (config.spreadPercent / 100) * positionSize / 2; // Half spread on entry
            
            // Exit costs (same)
            const exitFee = (feeRate / 100) * positionSize;
            const exitSlippage = (config.slippagePercent / 100) * positionSize;
            const exitSpread = (config.spreadPercent / 100) * positionSize / 2;
            
            // Total round-trip
            const totalFees = entryFee + exitFee;
            const totalSlippage = entrySlippage + exitSlippage;
            const totalSpread = entrySpread + exitSpread;
            const totalCost = totalFees + totalSlippage + totalSpread + config.gasFeeUSD;
            
            return {
                entryFee,
                exitFee,
                totalFees,
                slippage: totalSlippage,
                spread: totalSpread,
                gas: config.gasFeeUSD,
                total: totalCost,
                totalPercent: (totalCost / positionSize) * 100,
                breakEvenPercent: (totalCost / positionSize) * 100 // Need this % gain to break even
            };
        }

        const state = {
            balance: 1000,
            sessionPnL: 0,
            trades: [],
            wins: 0,
            connected: false,
            
            // Current trade
            inTrade: false,
            currentTrade: null,
            tradeStartTime: null,
            
            // Learning data
            exitPatterns: [],
            autoMode: false,
            aiConfidence: 0,
            
            // Auto-test mode
            testMode: false,
            testTradesTarget: 25,
            testTradesCompleted: 0,
            testStartBalance: 1000,
            testResults: []
        };

        // =============================================
        // DOM ELEMENTS
        // =============================================
        const el = {
            connDot: document.getElementById('conn-dot'),
            connText: document.getElementById('conn-text'),
            balance: document.getElementById('balance'),
            sessionPnL: document.getElementById('session-pnl'),
            winRate: document.getElementById('win-rate'),
            avgExit: document.getElementById('avg-exit'),
            tradeCount: document.getElementById('trade-count'),
            aiConfidence: document.getElementById('ai-confidence'),
            scannerGrid: document.getElementById('scanner-grid'),
            noTrade: document.getElementById('no-trade'),
            tradePanel: document.getElementById('trade-panel'),
            tradeSymbol: document.getElementById('trade-symbol'),
            currentPrice: document.getElementById('current-price'),
            entryPrice: document.getElementById('entry-price'),
            positionSize: document.getElementById('position-size'),
            pnlDisplay: document.getElementById('pnl-display'),
            timerFill: document.getElementById('timer-fill'),
            sellButton: document.getElementById('sell-button'),
            // Fee breakdown elements
            grossPnl: document.getElementById('gross-pnl'),
            feeAmount: document.getElementById('fee-amount'),
            slippageAmount: document.getElementById('slippage-amount'),
            spreadAmount: document.getElementById('spread-amount'),
            breakevenPct: document.getElementById('breakeven-pct'),
            // Learning elements
            learningProgress: document.getElementById('learning-progress'),
            learningStatus: document.getElementById('learning-status'),
            learnTrades: document.getElementById('learn-trades'),
            learnPattern: document.getElementById('learn-pattern'),
            learnTiming: document.getElementById('learn-timing'),
            autoToggleSection: document.getElementById('auto-toggle-section'),
            autoToggle: document.getElementById('auto-toggle'),
            autoStatus: document.getElementById('auto-status'),
            patternsList: document.getElementById('patterns-list'),
            historyMini: document.getElementById('history-mini'),
            modeIndicator: document.getElementById('mode-indicator'),
            modeIcon: document.getElementById('mode-icon'),
            modeText: document.getElementById('mode-text'),
            activeTrade: document.getElementById('active-trade')
        };

        // =============================================
        // VOLATILITY TRACKING
        // =============================================
        const volatilityData = new Map();

        function updateVolatility(symbol, price) {
            let data = volatilityData.get(symbol);
            if (!data) {
                data = {
                    prices: [],
                    timestamps: [],
                    beta: 0,
                    momentum: 0,
                    lastPrice: null
                };
                volatilityData.set(symbol, data);
            }

            // CRITICAL: Only record price if it actually changed (avoid duplicate prices from polling)
            if (price === data.lastPrice) {
                return; // Skip unchanged prices to avoid zero-return inflation
            }

            const now = Date.now();
            data.prices.push(price);
            data.timestamps.push(now);
            data.lastPrice = price;

            // Keep last 60 seconds of data for better analysis
            const cutoff = now - 60000;
            while (data.timestamps.length > 0 && data.timestamps[0] < cutoff) {
                data.prices.shift();
                data.timestamps.shift();
            }

            // Calculate beta (volatility) - standard deviation of returns
            if (data.prices.length > 5) {
                const returns = [];
                for (let i = 1; i < data.prices.length; i++) {
                    returns.push((data.prices[i] - data.prices[i-1]) / data.prices[i-1] * 100);
                }
                const mean = returns.reduce((a,b) => a+b, 0) / returns.length;
                const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
                data.beta = Math.sqrt(variance);

                // Momentum: recent price direction (last 5 ticks)
                const recentPrices = data.prices.slice(-5);
                data.momentum = (recentPrices[recentPrices.length-1] - recentPrices[0]) / recentPrices[0] * 100;
                
                // MEAN REVERSION: Detect oversold/overbought for reversal trades
                if (data.prices.length >= 20) {
                    const longPrices = data.prices.slice(-20);
                    const mean = longPrices.reduce((a,b) => a+b) / longPrices.length;
                    const currentPrice = recentPrices[recentPrices.length-1];
                    data.meanDeviation = ((currentPrice - mean) / mean) * 100; // % from mean
                    // Oversold = negative deviation (deeper threshold for quality)
                    data.isOversold = data.meanDeviation < -0.10; // 0.10% below mean (was 0.05%, too sensitive)
                    data.isOverbought = data.meanDeviation > 0.10;  // 0.10% above mean
                } else {
                    data.meanDeviation = 0;
                    data.isOversold = false;
                    data.isOverbought = false;
                }
                
                // DEBUG: Log first symbol to see typical values
                if (symbol === 'BTC' && data.prices.length % 50 === 0) {
                    console.log(`[DEBUG ${symbol}] beta=${data.beta.toFixed(6)}, momentum=${data.momentum.toFixed(6)}%, prices=${data.prices.length}, recent returns:`, returns.slice(-5).map(r => r.toFixed(6)));
                }
                
                // SPIKE DETECTION: Compare last 5 seconds volatility to previous average
                const recentReturns = returns.slice(-10);
                const olderReturns = returns.slice(0, -10);
                if (recentReturns.length >= 5 && olderReturns.length >= 5) {
                    const recentVol = Math.sqrt(recentReturns.reduce((s, r) => s + r*r, 0) / recentReturns.length);
                    const olderVol = Math.sqrt(olderReturns.reduce((s, r) => s + r*r, 0) / olderReturns.length);
                    data.spikeRatio = olderVol > 0 ? recentVol / olderVol : 1;
                } else {
                    data.spikeRatio = 1;
                }
                
                // RANGE: Expected move in next 30 seconds based on current volatility
                data.expectedMove = data.beta * Math.sqrt(30); // Rough estimate
                
                // TREND STRENGTH: How consistent is the direction?
                let upMoves = 0, downMoves = 0;
                for (const r of recentReturns) {
                    if (r > 0) upMoves++;
                    else if (r < 0) downMoves++;
                }
                data.trendStrength = Math.abs(upMoves - downMoves) / recentReturns.length;
                data.trendDirection = upMoves > downMoves ? 1 : -1;
            }

            data.lastPrice = price;
            return data;
        }

        // =============================================
        // SCANNER RENDERING
        // =============================================
        function renderScanner() {
            const items = [];
            
            volatilityData.forEach((data, symbol) => {
                if (data.prices.length < 5) return; // Need at least 5 price points
                
                // Match actual volatility: beta ~0.001
                const isExtreme = data.beta >= 0.002;
                const isSpiking = data.beta >= 0.001 || data.spikeRatio > 2;
                const isHot = data.beta >= 0.0005;
                
                // ENTRY SIGNAL: Any volatility at all
                const hasEntrySignal = data.beta >= 0.0005;
                
                items.push({
                    symbol,
                    price: data.lastPrice,
                    beta: data.beta,
                    momentum: data.momentum,
                    spikeRatio: data.spikeRatio || 1,
                    expectedMove: data.expectedMove || 0,
                    trendStrength: data.trendStrength || 0,
                    trendDirection: data.trendDirection || 0,
                    isHot,
                    isSpiking,
                    isExtreme,
                    hasEntrySignal
                });
            });

            // Sort by: Entry signals first, then by beta
            items.sort((a, b) => {
                if (a.hasEntrySignal && !b.hasEntrySignal) return -1;
                if (!a.hasEntrySignal && b.hasEntrySignal) return 1;
                if (a.isExtreme && !b.isExtreme) return -1;
                if (!a.isExtreme && b.isExtreme) return 1;
                return b.beta - a.beta;
            });

            if (items.length === 0) {
                el.scannerGrid.innerHTML = `
                    <div style="text-align:center;padding:40px;color:#666;">
                        <div class="spinner" style="width:30px;height:30px;border:3px solid rgba(255,255,255,0.1);border-top-color:#667eea;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 15px;"></div>
                        Scanning for volatility spikes...
                    </div>
                `;
                return;
            }

            el.scannerGrid.innerHTML = items.slice(0, 12).map(item => {
                const volPercent = Math.min(100, (item.beta / 0.5) * 100);
                const volClass = item.isExtreme ? 'extreme' : (item.isSpiking ? 'high' : (item.isHot ? 'medium' : 'low'));
                
                // Determine item styling
                let itemClass = '';
                let signalBadge = '';
                
                if (item.hasEntrySignal) {
                    itemClass = 'entry-signal';
                    const direction = item.trendDirection > 0 ? 'üöÄ LONG' : 'üìâ SHORT';
                    signalBadge = `<span class="signal-badge">${direction}</span>`;
                } else if (item.isExtreme) {
                    itemClass = 'extreme';
                    signalBadge = `<span class="extreme-badge">üî• EXTREME</span>`;
                } else if (item.isSpiking) {
                    itemClass = 'spiking';
                } else if (item.isHot) {
                    itemClass = 'hot';
                }
                
                const momentumIcon = item.momentum > 0 ? 'üìà' : 'üìâ';
                const trendBar = item.trendStrength > 0.5 ? '‚ñà‚ñà‚ñà‚ñà' : (item.trendStrength > 0.3 ? '‚ñà‚ñà‚ñà' : '‚ñà‚ñà');
                
                return `
                    <div class="scan-item ${itemClass}" 
                         onclick="enterTrade('${item.symbol}', ${item.price})"
                         title="Click to trade ${item.symbol} - Bot will decide direction">
                        <span class="symbol">${item.symbol} ${signalBadge}</span>
                        <span class="price">$${formatPrice(item.price)}</span>
                        <div class="volatility-bar">
                            <div class="volatility-fill ${volClass}" style="width:${volPercent}%"></div>
                        </div>
                        <span class="beta-value" style="color:${item.isExtreme ? '#ff3333' : (item.isSpiking ? '#ff6b6b' : (item.isHot ? '#ffd93d' : '#6bcb77'))}">
                            Œ≤ ${item.beta.toFixed(3)}
                        </span>
                        <span title="Expected move: ¬±${item.expectedMove.toFixed(2)}%">${momentumIcon} ${item.momentum > 0 ? '+' : ''}${item.momentum.toFixed(2)}%</span>
                    </div>
                `;
            }).join('');
        }

        // =============================================
        // TRADING LOGIC
        // =============================================
        function enterTrade(symbol, price) {
            if (state.inTrade) {
                console.log('‚ö†Ô∏è Already in a trade, cannot enter new position');
                return;
            }

            state.inTrade = true;
            
            // BOT DECIDES DIRECTION using strategies
            const volData = volatilityData.get(symbol);
            let direction, strategyType, confidence;
            
            if (!volData || volData.prices.length < 5) {
                console.log('‚ö†Ô∏è Not enough data for', symbol);
                state.inTrade = false;
                return;
            }
            
            // TEST #3 WINNING CONFIG: Simple mean reversion
            // Œ≤‚â•0.05, oversold, momentum‚â•0, LONG only
            if (!volData.isOversold || volData.beta < 0.05 || (volData.momentum || 0) < 0) {
                console.log(`‚ö†Ô∏è ${symbol} doesn't meet entry criteria (oversold=${volData.isOversold}, dev=${(volData.meanDeviation||0).toFixed(3)}%, Œ≤=${(volData.beta||0).toFixed(3)}, momentum=${(volData.momentum||0).toFixed(4)})`);
                state.inTrade = false;
                return;
            }
            
            // ONLY LONG mean reversion
            direction = 'long';
            strategyType = 'reversion';
            confidence = Math.min(0.95, 0.6 + Math.abs(volData.meanDeviation || 0) * 1.5);
            console.log(`üîÑ MEAN REVERSION: LONG (oversold by ${Math.abs(volData.meanDeviation || 0).toFixed(3)}%, Œ≤=${volData.beta.toFixed(3)})`);
            
            // CONSERVATIVE POSITION SIZING: $100 until profitable
            let positionSize = 100;
            
            state.currentTrade = {
                symbol,
                entryPrice: price,
                entryTime: Date.now(),
                size: positionSize,
                direction: direction,
                strategyType: strategyType,
                directionConfidence: confidence,
                beta: volData.beta || 0,
                momentum: volData.momentum || 0,
                meanDeviation: volData.meanDeviation || 0,
                straddleCandidate: volData.beta >= 0.03 && (volData.trendStrength || 1) < 0.4,
                priceHistory: [{ price, time: Date.now() }]
            };
            state.tradeStartTime = Date.now();
            
            // Subscribe to real-time updates for this symbol (WebSocket)
            if (hyperliquidPriceFeed.subscribeToSymbol) {
                hyperliquidPriceFeed.subscribeToSymbol(symbol);
                console.log(`üì° Subscribed to ${symbol} real-time price feed`);
            }

            // Update UI
            el.noTrade.style.display = 'none';
            el.tradePanel.style.display = 'block';
            el.activeTrade.classList.add('in-trade');
            
            const directionHint = direction === 'long' ? ' üöÄ' : ' üìâ';
            el.tradeSymbol.textContent = symbol + directionHint;
            el.entryPrice.textContent = `$${formatPrice(price)}`;
            el.positionSize.textContent = `$${positionSize}`; // Use actual position size, not config
            
            updateTradeDisplay();
            
            // Log entry details with confidence and strategy
            const confidenceLabel = confidence > 0.7 ? 'HIGH' : confidence > 0.5 ? 'MEDIUM' : 'LOW';
            const strategyEmoji = strategyType === 'reversion' ? 'üîÑ' : strategyType === 'momentum' ? 'üìà' : 'üéØ';
            console.log(`${strategyEmoji} ${strategyType.toUpperCase()}: ${symbol} @ $${formatPrice(price)} (${direction.toUpperCase()} - ${confidenceLabel} ${(confidence*100).toFixed(0)}%)`);
            
            if (state.currentTrade.straddleCandidate) {
                console.log(`üí° Note: High volatility (Œ≤=${state.currentTrade.beta.toFixed(4)}) + weak trend - could trade both directions`);
            }
            
            // Start monitoring if NOT in test mode (test mode handles its own monitoring)
            if (!state.testMode) {
                console.log('üëÜ Manual trade - monitoring started (press SPACE or click SELL to exit)');
                monitorManualTrade();
            }
        }

        function updateTradeDisplay() {
            if (!state.inTrade || !state.currentTrade) return;

            const trade = state.currentTrade;
            const currentPrice = hyperliquidPriceFeed.getPrice(trade.symbol);
            
            if (!currentPrice) return;

            // Track price history
            trade.priceHistory.push({ price: currentPrice, time: Date.now() });

            // Calculate P&L with EXACT fees (what you'd pay with a real wallet)
            const grossPnlPercent = ((currentPrice - trade.entryPrice) / trade.entryPrice) * 100;
            const grossPnlDollar = (grossPnlPercent / 100) * trade.size;
            
            // Get exact trading costs
            const costs = calculateTradingCosts(trade.size, true); // true = market order
            
            // Net P&L after ALL costs
            const pnlDollar = grossPnlDollar - costs.total;
            const pnlPercent = (pnlDollar / trade.size) * 100;
            const isProfit = pnlDollar >= 0;
            
            // Store for analysis
            trade.currentGrossPnl = grossPnlDollar;
            trade.currentCosts = costs;
            trade.currentNetPnl = pnlDollar;

            // Update price display
            el.currentPrice.textContent = `$${formatPrice(currentPrice)}`;
            el.currentPrice.className = `current-price ${isProfit ? 'profit' : 'loss'}`;

            // Update P&L
            el.pnlDisplay.textContent = `${isProfit ? '+' : ''}$${pnlDollar.toFixed(2)} (${pnlPercent > 0 ? '+' : ''}${pnlPercent.toFixed(3)}%)`;
            el.pnlDisplay.className = `pnl-display ${isProfit ? 'profit' : 'loss'}`;

            // Update fee breakdown display
            el.grossPnl.textContent = `${grossPnlDollar >= 0 ? '+' : ''}$${grossPnlDollar.toFixed(4)}`;
            el.grossPnl.style.color = grossPnlDollar >= 0 ? '#6bcb77' : '#ff6b6b';
            el.feeAmount.textContent = `-$${costs.totalFees.toFixed(4)}`;
            el.slippageAmount.textContent = `-$${costs.slippage.toFixed(4)}`;
            el.spreadAmount.textContent = `-$${costs.spread.toFixed(4)}`;
            el.breakevenPct.textContent = `+${costs.breakEvenPercent.toFixed(3)}%`;

            // Update timer
            const elapsed = Date.now() - state.tradeStartTime;
            const remaining = Math.max(0, (config.tradeWindowSeconds * 1000) - elapsed);
            const percent = (remaining / (config.tradeWindowSeconds * 1000)) * 100;
            el.timerFill.style.width = `${percent}%`;

            // Detect momentum reversal - SELL signal
            const volData = volatilityData.get(trade.symbol);
            // Check for momentum reversal (price moving against our trade direction)
            const momentumReversing = volData && 
                                      Math.abs(volData.momentum) > 0.1 && // Needs significant movement
                                      ((trade.direction === 'long' && volData.momentum < -0.1) || 
                                       (trade.direction === 'short' && volData.momentum > 0.1));

            // Update sell button - always enabled, different styling
            el.sellButton.disabled = false;
            if (isProfit && pnlDollar > costs.totalFees * 2) {
                // Good profit - definitely sell
                el.sellButton.className = 'sell-button ready';
                el.sellButton.textContent = `üöÄ SELL NOW +$${pnlDollar.toFixed(2)}`;
            } else if (isProfit && momentumReversing && pnlDollar > costs.totalFees * 1.2) {
                // Profit but momentum reversing - sell before it turns
                el.sellButton.className = 'sell-button ready';
                el.sellButton.textContent = `‚ö° SELL QUICK +$${pnlDollar.toFixed(2)} (reversal!)`;
            } else if (isProfit && pnlDollar > costs.totalFees) {
                // Small profit, but covers all costs
                el.sellButton.className = 'sell-button ready';
                el.sellButton.textContent = `üí∞ SELL +$${pnlDollar.toFixed(2)}`;
            } else if (momentumReversing || remaining < 5000) {
                // Losing and momentum against us - cut loss
                el.sellButton.className = 'sell-button loss-exit';
                el.sellButton.textContent = `üõë CUT LOSS -$${Math.abs(pnlDollar).toFixed(2)}`;
            } else {
                // Still losing but maybe it'll turn
                el.sellButton.className = 'sell-button loss-exit';
                el.sellButton.textContent = `‚è≥ HOLD or EXIT -$${Math.abs(pnlDollar).toFixed(2)}`;
            }

            // Auto-close if timer expires
            if (remaining <= 0) {
                exitTrade('timeout');
            }

            // AUTO-TRADE: If enabled and pattern matches
            if (state.autoMode && isProfit) {
                const holdTime = Date.now() - trade.entryTime;
                const optimalExit = getOptimalExitPattern();
                
                if (optimalExit && pnlPercent >= optimalExit.minProfit && holdTime >= optimalExit.minHoldTime) {
                    console.log('ü§ñ Auto-trade triggered!');
                    exitTrade('auto');
                }
            }
        }

        function exitTrade(reason = 'manual') {
            if (!state.inTrade || !state.currentTrade) return;

            const trade = state.currentTrade;
            const exitPrice = hyperliquidPriceFeed.getPrice(trade.symbol);
            const exitTime = Date.now();
            
            const grossPnlPercent = ((exitPrice - trade.entryPrice) / trade.entryPrice) * 100;
            const grossPnlDollar = (grossPnlPercent / 100) * trade.size;
            const costs = calculateTradingCosts(trade.size, true);
            const pnlDollar = grossPnlDollar - costs.total;
            const pnlPercent = (pnlDollar / trade.size) * 100;
            const holdTime = exitTime - trade.entryTime;
            const isWin = pnlDollar > 0;

            // Update state
            state.balance += pnlDollar;
            state.sessionPnL += pnlDollar;
            if (isWin) state.wins++;
            
            // CRITICAL: Record test results for ANY exit during test mode
            if (state.testMode) {
                const volData = volatilityData.get(trade.symbol);
                // Get entry vs exit data for analysis
                const entryVolData = {
                    beta: trade.beta || 0,
                    momentum: trade.momentum || 0,
                    confidence: trade.directionConfidence || 0.5,
                    trendStrength: volatilityData.get(trade.symbol)?.trendStrength || 0
                };
                const exitVolData = {
                    beta: volData?.beta || 0,
                    momentum: volData?.momentum || 0,
                    trendStrength: volData?.trendStrength || 0
                };
                
                state.testResults.push({
                    symbol: trade.symbol,
                    direction: trade.direction,
                    directionLabel: trade.direction === 'long' ? 'LONG' : 'SHORT',
                    strategy: trade.strategyType || 'unknown',
                    entryPrice: trade.entryPrice,
                    exitPrice: exitPrice,
                    grossPnl: grossPnlDollar,
                    costs: costs.total,
                    pnl: pnlDollar,
                    pnlPercent: pnlPercent,
                    pnlMultiple: pnlDollar / costs.total, // How many costs we made/lost
                    holdTime: holdTime,
                    exitReason: reason,
                    // Entry conditions
                    entryBeta: entryVolData.beta,
                    entryMomentum: entryVolData.momentum,
                    entryConfidence: entryVolData.confidence,
                    entryTrend: entryVolData.trendStrength,
                    entryMeanDev: volData?.meanDeviation || 0,
                    // Exit conditions
                    exitBeta: exitVolData.beta,
                    exitMomentum: exitVolData.momentum,
                    exitTrend: exitVolData.trendStrength,
                    exitMeanDev: volData?.meanDeviation || 0,
                    // Changes
                    betaChange: exitVolData.beta - entryVolData.beta,
                    momentumChange: exitVolData.momentum - entryVolData.momentum,
                    meanDevChange: (volData?.meanDeviation || 0) - (volData?.meanDeviation || 0),
                    // Price action
                    priceChange: exitPrice - trade.entryPrice,
                    priceChangePercent: ((exitPrice - trade.entryPrice) / trade.entryPrice) * 100,
                    // Trade quality
                    wasHighBeta: entryVolData.beta >= 0.02,
                    wasHighConfidence: entryVolData.confidence >= 0.7,
                    hadMomentumReversal: Math.sign(entryVolData.momentum) !== Math.sign(exitVolData.momentum),
                    wasProfitable: pnlDollar > 0,
                    timestamp: Date.now()
                });
                
                state.testTradesCompleted++;
                
                // Update button
                const btn = document.getElementById('test-mode-btn');
                btn.textContent = `ü§ñ Running Test (${state.testTradesCompleted}/${state.testTradesTarget})`;
                
                // Continue to next trade after short delay
                setTimeout(() => runNextTestTrade(), 1000);
            }

            // Record trade with full analysis data
            const tradeRecord = {
                symbol: trade.symbol,
                entryPrice: trade.entryPrice,
                exitPrice: exitPrice,
                grossPnl: grossPnlDollar,
                costs: costs, // Full cost breakdown
                fees: costs.totalFees,
                slippage: costs.slippage,
                spread: costs.spread,
                totalCosts: costs.total,
                pnl: pnlDollar,
                pnlPercent: pnlPercent,
                holdTime: holdTime,
                exitReason: reason,
                timestamp: exitTime,
                priceHistory: trade.priceHistory,
                beta: volatilityData.get(trade.symbol)?.beta || 0,
                momentum: volatilityData.get(trade.symbol)?.momentum || 0
            };
            state.trades.push(tradeRecord);
            
            // Run trade analysis
            analyzeTradePerformance(tradeRecord);

            // Learn from this trade (only manual exits)
            if (reason === 'manual' && isWin) {
                learnFromTrade(tradeRecord);
            }

            // Reset trade state
            state.inTrade = false;
            state.currentTrade = null;
            
            // Update UI
            el.noTrade.style.display = 'block';
            el.tradePanel.style.display = 'none';
            el.activeTrade.classList.remove('in-trade');

            updateStats();
            renderHistory();
            saveState();

            console.log(`${isWin ? '‚úÖ' : '‚ùå'} Exited ${trade.symbol}: ${isWin ? '+' : ''}$${pnlDollar.toFixed(2)} (${reason})`);
        }

        // =============================================
        // TRADE ANALYSIS ENGINE
        // =============================================
        function analyzeTradePerformance(trade) {
            console.log('üìä Analyzing trade:', trade);
            
            // Calculate key metrics
            const analysis = {
                // Efficiency: How much of gross profit was kept after costs
                efficiency: trade.grossPnl > 0 ? (trade.pnl / trade.grossPnl) * 100 : 0,
                
                // Cost ratio: What % of position went to fees
                costRatio: (trade.totalCosts / config.positionSize) * 100,
                
                // Hold efficiency: P&L per second held
                pnlPerSecond: trade.pnl / (trade.holdTime / 1000),
                
                // Beta correlation: Did high beta lead to profit?
                betaEffective: trade.beta > 0.3 && trade.pnl > 0,
                
                // Timing score: Early exit (good) vs late exit (forced)
                timingScore: trade.exitReason === 'manual' ? 100 : 
                            (trade.exitReason === 'auto' ? 80 : 20)
            };
            
            // Log analysis
            console.log('üìà Trade Analysis:', {
                symbol: trade.symbol,
                grossPnL: `$${trade.grossPnl.toFixed(4)}`,
                costs: `$${trade.totalCosts.toFixed(4)}`,
                netPnL: `$${trade.pnl.toFixed(4)}`,
                efficiency: `${analysis.efficiency.toFixed(1)}%`,
                holdTime: `${(trade.holdTime/1000).toFixed(1)}s`,
                exitReason: trade.exitReason
            });
            
            // Generate insights
            const insights = [];
            
            if (trade.pnl < 0 && trade.grossPnl > 0) {
                insights.push(`‚ö†Ô∏è Costs ate your profit! Gross was +$${trade.grossPnl.toFixed(4)} but costs were $${trade.totalCosts.toFixed(4)}`);
            }
            
            if (trade.holdTime < 3000 && trade.pnl > 0) {
                insights.push(`‚ö° Quick profit! ${(trade.holdTime/1000).toFixed(1)}s hold - great timing`);
            }
            
            if (trade.holdTime > 20000 && trade.pnl < 0) {
                insights.push(`üêå Held too long. Consider cutting losses earlier`);
            }
            
            if (trade.beta > 0.5 && trade.pnl > 0) {
                insights.push(`üéØ High beta (${trade.beta.toFixed(3)}) + profit = good volatility pick`);
            }
            
            if (analysis.efficiency < 50 && trade.grossPnl > 0) {
                insights.push(`üí∏ Low efficiency (${analysis.efficiency.toFixed(0)}%) - costs took over half your gross`);
            }
            
            // Store insights for display
            if (insights.length > 0) {
                console.log('üí° Insights:', insights);
            }
            
            return { analysis, insights };
        }

        // =============================================
        // LEARNING SYSTEM
        // =============================================
        function learnFromTrade(trade) {
            state.exitPatterns.push({
                pnlPercent: trade.pnlPercent,
                holdTime: trade.holdTime,
                symbol: trade.symbol,
                beta: volatilityData.get(trade.symbol)?.beta || 0
            });

            updateLearningProgress();
        }

        function updateLearningProgress() {
            const tradesNeeded = config.tradesForAutoUnlock;
            const currentTrades = state.exitPatterns.length;
            const progress = Math.min(100, (currentTrades / tradesNeeded) * 100);

            el.learningProgress.style.width = `${progress}%`;
            el.learningProgress.textContent = `${Math.round(progress)}%`;
            el.learnTrades.textContent = `${currentTrades}/${tradesNeeded}`;

            // Calculate learned patterns
            if (currentTrades >= 5) {
                const avgPnl = state.exitPatterns.reduce((a, b) => a + b.pnlPercent, 0) / currentTrades;
                const avgHold = state.exitPatterns.reduce((a, b) => a + b.holdTime, 0) / currentTrades;

                el.learnPattern.textContent = `+${avgPnl.toFixed(2)}%`;
                el.learnTiming.textContent = `${(avgHold / 1000).toFixed(1)}s`;

                // Update patterns display
                el.patternsList.innerHTML = `
                    <div class="pattern-item">
                        <span>Avg Profit Target</span>
                        <span style="color:#6bcb77">+${avgPnl.toFixed(3)}%</span>
                    </div>
                    <div class="pattern-item">
                        <span>Avg Hold Duration</span>
                        <span>${(avgHold / 1000).toFixed(1)}s</span>
                    </div>
                    <div class="pattern-item">
                        <span>Best Single Trade</span>
                        <span style="color:#6bcb77">+${Math.max(...state.exitPatterns.map(p => p.pnlPercent)).toFixed(3)}%</span>
                    </div>
                `;
            }

            // Unlock auto-trade
            if (currentTrades >= tradesNeeded) {
                el.autoToggleSection.style.display = 'flex';
                el.learningStatus.textContent = 'üéâ Auto-trading unlocked! Toggle to let AI trade for you.';
                el.learningStatus.style.color = '#6bcb77';

                // Calculate AI confidence
                const winRate = state.wins / state.trades.length;
                state.aiConfidence = Math.min(95, Math.round(winRate * 100 + currentTrades));
                el.aiConfidence.textContent = `${state.aiConfidence}%`;
            }
        }

        function getOptimalExitPattern() {
            if (state.exitPatterns.length < config.tradesForAutoUnlock) return null;

            const avgPnl = state.exitPatterns.reduce((a, b) => a + b.pnlPercent, 0) / state.exitPatterns.length;
            const avgHold = state.exitPatterns.reduce((a, b) => a + b.holdTime, 0) / state.exitPatterns.length;

            return {
                minProfit: avgPnl * 0.8, // Exit at 80% of average profit
                minHoldTime: avgHold * 0.5 // Minimum half the average hold time
            };
        }

        // =============================================
        // UI UPDATES
        // =============================================
        function updateStats() {
            el.balance.textContent = `$${state.balance.toFixed(2)}`;
            
            el.sessionPnL.textContent = `${state.sessionPnL >= 0 ? '+' : ''}$${state.sessionPnL.toFixed(2)}`;
            el.sessionPnL.className = `value ${state.sessionPnL >= 0 ? 'green' : 'red'}`;

            const winRate = state.trades.length > 0 ? (state.wins / state.trades.length * 100) : 0;
            el.winRate.textContent = `${winRate.toFixed(1)}%`;

            if (state.trades.length > 0) {
                const avgExit = state.trades.reduce((a, b) => a + b.holdTime, 0) / state.trades.length;
                el.avgExit.textContent = `${(avgExit / 1000).toFixed(1)}s`;
            }

            el.tradeCount.textContent = state.trades.length;

            // Update mode indicator
            if (state.autoMode) {
                el.modeIndicator.className = 'mode-indicator auto';
                el.modeIcon.textContent = 'ü§ñ';
                el.modeText.textContent = 'Auto Mode';
            } else if (state.exitPatterns.length >= 10) {
                el.modeIndicator.className = 'mode-indicator learning';
                el.modeIcon.textContent = 'üß†';
                el.modeText.textContent = 'Learning...';
            } else {
                el.modeIndicator.className = 'mode-indicator manual';
                el.modeIcon.textContent = 'üëÜ';
                el.modeText.textContent = 'Manual Mode';
            }
        }

        function renderHistory() {
            if (state.trades.length === 0) {
                el.historyMini.innerHTML = `<p style="color:#666;text-align:center;padding:20px;">No trades yet</p>`;
                return;
            }

            el.historyMini.innerHTML = state.trades.slice(-10).reverse().map(t => `
                <div class="history-item ${t.pnl >= 0 ? 'win' : 'loss'}">
                    <span>${t.symbol}</span>
                    <span>${(t.holdTime / 1000).toFixed(1)}s</span>
                    <span style="color:${t.pnl >= 0 ? '#6bcb77' : '#ff6b6b'}">
                        ${t.pnl >= 0 ? '+' : ''}$${t.pnl.toFixed(2)}
                    </span>
                </div>
            `).join('');
        }

        function formatPrice(price) {
            if (price >= 1000) return price.toLocaleString('en-US', { maximumFractionDigits: 2 });
            if (price >= 1) return price.toFixed(2);
            if (price >= 0.01) return price.toFixed(4);
            return price.toFixed(6);
        }

        // =============================================
        // PERSISTENCE
        // =============================================
        function saveState() {
            localStorage.setItem('scalperState', JSON.stringify({
                balance: state.balance,
                trades: state.trades.slice(-100),
                wins: state.wins,
                exitPatterns: state.exitPatterns,
                autoMode: state.autoMode
            }));
        }

        function loadState() {
            const saved = localStorage.getItem('scalperState');
            if (saved) {
                const data = JSON.parse(saved);
                state.balance = data.balance || 1000;
                state.trades = data.trades || [];
                state.wins = data.wins || 0;
                state.exitPatterns = data.exitPatterns || [];
                state.autoMode = data.autoMode || false;
                
                // Recalculate session P&L
                state.sessionPnL = state.trades.reduce((a, b) => a + b.pnl, 0);
            }
        }

        // =============================================
        // EVENT LISTENERS
        // =============================================
        el.sellButton.addEventListener('click', () => exitTrade('manual'));

        el.autoToggle.addEventListener('click', () => {
            state.autoMode = !state.autoMode;
            el.autoToggle.classList.toggle('active', state.autoMode);
            el.autoStatus.textContent = state.autoMode ? 'ON' : 'OFF';
            updateStats();
            saveState();
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && state.inTrade) {
                e.preventDefault();
                // Always allow exit with space - profit or loss
                exitTrade('manual');
            }
            // DEBUG: Press 'D' to dump volatility data
            if (e.code === 'KeyD' && !state.inTrade) {
                console.log('\\n=== VOLATILITY DATA DUMP ===');
                const allData = [];
                volatilityData.forEach((data, symbol) => {
                    allData.push({
                        symbol,
                        beta: data.beta || 0,
                        momentum: data.momentum || 0,
                        trendStrength: data.trendStrength || 0,
                        prices: data.prices.length
                    });
                });
                allData.sort((a, b) => b.beta - a.beta);
                console.log('Top 20 by volatility:');
                console.table(allData.slice(0, 20));
                console.log('Bottom 20 by volatility:');
                console.table(allData.slice(-20));
                console.log('=========================\\n');
            }
        });

        // =============================================
        // AUTO-TEST MODE
        // =============================================
        function forceTestTrade() {
            console.log('\\n‚ö° FORCING A TRADE - Taking best available...');
            const best = findBestTradeOpportunity();
            if (best) {
                enterTrade(best.symbol, best.price, best.direction);
                setTimeout(() => {
                    if (state.inTrade) {
                        monitorAndExitTrade();
                    }
                }, 100);
            } else {
                console.log('‚ùå No symbols available at all');
            }
        }
        
        function toggleTestMode() {
            if (state.testMode) {
                stopTestMode();
            } else {
                startTestMode();
            }
        }

        function startTestMode() {
            state.testMode = true;
            state.testTradesCompleted = 0;
            state.testStartBalance = state.balance;
            state.testResults = [];
            
            const btn = document.getElementById('test-mode-btn');
            btn.classList.add('running');
            btn.textContent = `ü§ñ Running Test (0/${state.testTradesTarget})`;
            
            console.log('ü§ñ AUTO-TEST MODE STARTED - Target: 25 trades');
            console.log('‚è≥ Waiting 3 seconds for volatility data to populate...');
            
            // Wait a bit for volatility data to populate
            setTimeout(() => {
                console.log('‚úÖ Starting test trades now!');
                runNextTestTrade();
            }, 3000);
        }

        function stopTestMode() {
            state.testMode = false;
            
            const btn = document.getElementById('test-mode-btn');
            btn.classList.remove('running');
            btn.textContent = 'ü§ñ Start Auto-Test (25 trades)';
            
            console.log('ü§ñ AUTO-TEST MODE STOPPED');
            
            // Show results
            showTestResults();
        }

        function runNextTestTrade() {
            if (!state.testMode || state.testTradesCompleted >= state.testTradesTarget) {
                stopTestMode();
                return;
            }
            
            // Wait until not in a trade
            if (state.inTrade) {
                setTimeout(() => runNextTestTrade(), 100);
                return;
            }
            
            console.log(`\nü§ñ [${state.testTradesCompleted + 1}/${state.testTradesTarget}] Looking for trade...`);
            
            // Find the best trade opportunity
            const bestTrade = findBestTradeOpportunity();
            
            if (!bestTrade) {
                // No good trade found, wait and try again
                const maxRetries = 20; // After 10 seconds (20 * 500ms), force a trade
                if (!state.testRetryCount) state.testRetryCount = 0;
                state.testRetryCount++;
                
                if (state.testRetryCount > maxRetries) {
                    console.log('‚ö†Ô∏è Too many retries, forcing a trade with any available data...');
                    state.testRetryCount = 0;
                    // Try again immediately - next attempt will use fallback logic
                    setTimeout(() => runNextTestTrade(), 100);
                    return;
                }
                
                console.log(`‚è≥ No trade found, waiting 500ms... (attempt ${state.testRetryCount}/${maxRetries})`);
                setTimeout(() => runNextTestTrade(), 500);
                return;
            }
            
            // Reset retry count on successful find
            state.testRetryCount = 0;
            
            // Enter the trade
            const directionEmoji = bestTrade.direction > 0 ? 'üìà' : 'üìâ';
            console.log(`üéØ ENTERING ${bestTrade.directionLabel}: ${bestTrade.symbol} @ $${bestTrade.price.toFixed(2)} ${directionEmoji}`);
            
            try {
                // Store trade metadata for exit decisions
                const tradeData = enterTrade(bestTrade.symbol, bestTrade.price, bestTrade.direction);
                if (state.currentTrade) {
                    state.currentTrade.directionConfidence = bestTrade.directionConfidence || 0.5;
                    state.currentTrade.straddleCandidate = bestTrade.straddleCandidate || false;
                }
                
                // Monitor and auto-exit
                monitorAndExitTrade();
            } catch (error) {
                console.error('‚ùå Error entering trade:', error);
                // Try next trade
                setTimeout(() => runNextTestTrade(), 1000);
            }
        }

        function findBestTradeOpportunity() {
            // Get all viable trade opportunities
            const opportunities = [];
            const highBetaOpportunities = []; // Track ALL high beta for analysis
            
            console.log(`üîç Scanning ${volatilityData.size} symbols for trade opportunities...`);
            
            volatilityData.forEach((data, symbol) => {
                // Log high-beta opportunities even if we don't trade them
                if (data.beta >= 0.06 && data.prices.length >= 3) {
                    highBetaOpportunities.push({
                        symbol,
                        beta: data.beta,
                        momentum: data.momentum || 0,
                        trendStrength: data.trendStrength || 0,
                        prices: data.prices.length
                    });
                }
                
                if (data.prices.length < 5) return; // Need at least 5 REAL price changes
                
                // TEST #3 WINNING CONFIG: Simple mean reversion
                // Œ≤‚â•0.05, oversold, momentum‚â•0, LONG only
                const hasStrongSignal = data.isOversold && 
                                       data.beta >= 0.05 && 
                                       (data.momentum || 0) >= 0;
                
                if (hasStrongSignal) {
                    direction = 1; // Always long
                    strategyType = 'reversion';
                    confidence = Math.min(0.95, 0.6 + Math.abs(data.meanDeviation || 0) * 1.5);
                    
                    // Check if volatility is extreme enough for straddle (both directions)
                    const straddleCandidate = data.beta >= 0.03 && data.trendStrength < 0.4;
                    
                    opportunities.push({
                        symbol,
                        price: data.lastPrice,
                        beta: data.beta,
                        momentum: data.momentum,
                        meanDeviation: data.meanDeviation || 0,
                        trendStrength: data.trendStrength || 0.5,
                        direction: direction,
                        directionLabel: direction > 0 ? 'LONG' : 'SHORT',
                        strategyType: strategyType,
                        directionConfidence: confidence,
                        straddleCandidate: straddleCandidate,
                        score: (data.beta * 1000) * confidence // Score by vol √ó confidence
                    });
                }
            });
            
            console.log(`üìä Found ${opportunities.length} STRONG opportunities`);
            
            if (opportunities.length === 0) {
                console.log('‚ö†Ô∏è No STRONG signals - skipping trade');
                return null; // Don't trade weak signals!
            }
            
            // Sort by score (highest first)
            opportunities.sort((a, b) => b.score - a.score);
            
            // LOG: High-beta opportunities for analysis
            if (highBetaOpportunities.length > 0) {
                highBetaOpportunities.sort((a, b) => b.beta - a.beta);
                const top3 = highBetaOpportunities.slice(0, 3);
                console.log('üî• High-Beta Opportunities (Œ≤‚â•0.01):', 
                    top3.map(o => `${o.symbol}(Œ≤=${o.beta.toFixed(4)} mom=${o.momentum.toFixed(3)}%)`).join(', '));
            }
            
            // LOG: Straddle candidates
            const straddleCandidates = opportunities.filter(o => o.straddleCandidate);
            if (straddleCandidates.length > 0) {
                console.log('‚ö° STRADDLE Candidates (high Œ≤, weak trend):', 
                    straddleCandidates.slice(0, 2).map(o => 
                        `${o.symbol}(Œ≤=${o.beta.toFixed(4)} trend=${o.trendStrength.toFixed(2)})`).join(', '));
            }
            
            // Penalize recently traded symbols for diversity
            if (state.testResults && state.testResults.length > 0) {
                const recentSymbols = state.testResults.slice(-10).map(t => t.symbol); // Check last 10 trades
                opportunities.forEach(opp => {
                    const timesTraded = recentSymbols.filter(s => s === opp.symbol).length;
                    if (timesTraded > 0) {
                        opp.score *= (0.1 ** timesTraded); // EXTREME penalty: 90% reduction per trade
                    }
                });
                opportunities.sort((a, b) => b.score - a.score);
                console.log(`üîÑ Diversified selection (last 10 trades had ${new Set(recentSymbols).size} unique symbols)`);
            }
            
            console.log(`‚úÖ Best opportunity: ${opportunities[0].symbol} (Œ≤=${opportunities[0].beta.toFixed(4)}, mom=${opportunities[0].momentum.toFixed(3)}%)`);
            
            // Debug: show top 5 opportunities to see what we're choosing from
            if (opportunities.length > 1) {
                const top5 = opportunities.slice(0, 5).map(o => 
                    `${o.symbol}(${o.directionLabel} Œ≤=${o.beta.toFixed(3)} mom=${o.momentum.toFixed(2)}%)`
                ).join(', ');
                console.log(`üîç Top candidates: ${top5}`);
            }
            
            return opportunities[0];
        }

        function monitorManualTrade() {
            // Manual trade monitoring - just timeout, user exits manually
            if (!state.inTrade) return;
            
            const trade = state.currentTrade;
            const elapsed = Date.now() - state.tradeStartTime;
            const remaining = Math.max(0, (config.tradeWindowSeconds * 1000) - elapsed);
            
            // Auto-exit on timeout
            if (remaining <= 0) {
                console.log('‚è±Ô∏è Manual trade timeout - auto-exiting');
                exitTrade('timeout');
                return;
            }
            
            // Keep monitoring
            setTimeout(() => monitorManualTrade(), 100);
        }
        
        function monitorAndExitTrade() {
            if (!state.inTrade || !state.testMode) return;
            
            const trade = state.currentTrade;
            const currentPrice = hyperliquidPriceFeed.getPrice(trade.symbol);
            if (!currentPrice) {
                setTimeout(() => monitorAndExitTrade(), 10); // Check every 10ms for instant reactions
                return;
            }
            
            // Calculate P&L
            const rawPnl = trade.direction === 'long' ? 
                (currentPrice - trade.entryPrice) : 
                (trade.entryPrice - currentPrice);
            const pnlPercent = (rawPnl / trade.entryPrice) * 100;
            
            const costs = calculateTradingCosts(config.positionSize);
            const grossPnl = (pnlPercent / 100) * config.positionSize;
            const netPnl = grossPnl - costs.total;
            
            const elapsed = Date.now() - state.tradeStartTime;
            const remaining = Math.max(0, (config.tradeWindowSeconds * 1000) - elapsed);
            
            // Get current volatility data
            const volData = volatilityData.get(trade.symbol);
            // Check for momentum reversal - price moving against our position
            const momentumReversing = volData && 
                                      Math.abs(volData.momentum) > 0.1 && // Needs 0.1% movement minimum
                                      ((trade.direction === 'long' && volData.momentum < -0.1) || 
                                       (trade.direction === 'short' && volData.momentum > 0.1));
            
            // EXIT CONDITIONS - DYNAMIC based on entry beta and current volatility
            let shouldExit = false;
            let exitReason = '';
            
            // Get entry beta and strategy for dynamic targets
            const entryBeta = trade.beta || 0.005;
            const strategy = trade.strategyType || 'multi';
            const isHighConfidence = (trade.directionConfidence || 0.5) >= 0.7;
            
            // SCALPING EXITS: Take profits FAST, cut losses FASTER  
            // Data shows: Winners exit quick (<10s), losers hold too long
            // Track peak profit for trailing stop
            if (!trade.peakPnl) trade.peakPnl = netPnl;
            if (netPnl > trade.peakPnl) trade.peakPnl = netPnl;
            
            // TEST #3 WINNING CONFIG - Simple exits
            // 1. QUICK PROFIT - Any profit after 5s
            if (netPnl > costs.total * 0.2 && elapsed > 5000) {
                shouldExit = true;
                exitReason = 'quick_profit';
            }
            // 2. PROFIT TARGET - 1x costs
            else if (netPnl > costs.total * 1.0) {
                shouldExit = true;
                exitReason = 'profit_target';
            }
            // 3. BIG PROFIT - 3x costs
            else if (netPnl > costs.total * 3.0) {
                shouldExit = true;
                exitReason = 'big_profit';
            }
            // 5. MEAN REVERSION COMPLETE - Price bounced back
            else if (strategy === 'reversion' && volData && Math.abs(volData.meanDeviation || 0) < 0.05) {
                // Price returned close to mean
                if (netPnl > -costs.total * 0.5) { // Exit even with small loss
                    shouldExit = true;
                    exitReason = 'reversion_complete';
                }
            }
            // 6. STOP LOSS - Cut losses FAST at -1x costs (tight stop, proven in Test #3)
            else if (netPnl < -costs.total * 1.0) {
                shouldExit = true;
                exitReason = 'fast_stop';
            }
            // 7. TAKE SMALL WIN if momentum weakening
            else if (netPnl > costs.total * 0.3 && volData && elapsed > 10000) {
                const entryMomentum = trade.momentum || 0.01;
                const momentumDrop = Math.abs(volData.momentum) < Math.abs(entryMomentum) * 0.5;
                if (momentumDrop) {
                    shouldExit = true;
                    exitReason = 'momentum_fade';
                }
            }
            // 8. Exit if near end of window and losing
            else if (remaining < 10000 && netPnl < -costs.total * 0.5) {
                shouldExit = true;
                exitReason = 'time_exit';
            }
            // 9. Take ANY profit near end of window
            else if (remaining < 10000 && netPnl > 0) {
                shouldExit = true;
                exitReason = 'time_profit';
            }
            // 10. Final timeout - exit no matter what
            else if (remaining <= 0) {
                shouldExit = true;
                exitReason = 'timeout';
            }
            
            if (shouldExit) {
                console.log(`ü§ñ Auto-exiting: ${exitReason}, P&L: $${netPnl.toFixed(2)}`);
                exitTrade(exitReason); // Use specific exit reason, recording happens in exitTrade()
            } else {
                // Check again VERY soon (10ms for real-time reactions)
                setTimeout(() => monitorAndExitTrade(), 10);
            }
        }

        function showTestResults() {
            console.log('\\n=== AUTO-TEST RESULTS ===');
            console.log(`Total Trades: ${state.testResults.length}`);
            
            const wins = state.testResults.filter(t => t.pnl > 0).length;
            const losses = state.testResults.filter(t => t.pnl < 0).length;
            const longs = state.testResults.filter(t => t.direction === 'long').length;
            const shorts = state.testResults.filter(t => t.direction === 'short').length;
            const totalPnl = state.testResults.reduce((sum, t) => sum + t.pnl, 0);
            const avgPnl = state.testResults.length > 0 ? totalPnl / state.testResults.length : 0;
            const winRate = state.testResults.length > 0 ? (wins / state.testResults.length) * 100 : 0;
            
            // Save to file for AI analysis
            saveTestResultsToFile();
            
            console.log(`Directions: ${longs} LONG / ${shorts} SHORT`);
            console.log(`Win Rate: ${winRate.toFixed(1)}% (${wins}W / ${losses}L)`);
            console.log(`Total P&L: $${totalPnl.toFixed(2)}`);
            console.log(`Avg P&L per trade: $${avgPnl.toFixed(2)}`);
            console.log(`Starting Balance: $${state.testStartBalance.toFixed(2)}`);
            console.log(`Ending Balance: $${state.balance.toFixed(2)}`);
            console.log(`Net Change: $${(state.balance - state.testStartBalance).toFixed(2)}`);
            
            // Analyze by direction
            const longTrades = state.testResults.filter(t => t.direction === 'long');
            const shortTrades = state.testResults.filter(t => t.direction === 'short');
            if (longTrades.length > 0) {
                const longWins = longTrades.filter(t => t.pnl > 0).length;
                const longPnl = longTrades.reduce((sum, t) => sum + t.pnl, 0);
                console.log(`\\nLONG Performance: ${((longWins/longTrades.length)*100).toFixed(1)}% WR, $${longPnl.toFixed(2)} P&L`);
            }
            if (shortTrades.length > 0) {
                const shortWins = shortTrades.filter(t => t.pnl > 0).length;
                const shortPnl = shortTrades.reduce((sum, t) => sum + t.pnl, 0);
                console.log(`SHORT Performance: ${((shortWins/shortTrades.length)*100).toFixed(1)}% WR, $${shortPnl.toFixed(2)} P&L`);
            }
            
            // Analyze exit reasons
            const exitReasons = {};
            state.testResults.forEach(t => {
                exitReasons[t.exitReason] = (exitReasons[t.exitReason] || 0) + 1;
            });
            console.log('\\nExit Reasons:', exitReasons);
            
            // Analyze best/worst trades
            if (state.testResults.length > 0) {
                const sorted = [...state.testResults].sort((a, b) => b.pnl - a.pnl);
                console.log(`\\nBest Trade: ${sorted[0].symbol} +$${sorted[0].pnl.toFixed(2)}`);
                console.log(`Worst Trade: ${sorted[sorted.length-1].symbol} ${sorted[sorted.length-1].pnl >= 0 ? '+' : ''}$${sorted[sorted.length-1].pnl.toFixed(2)}`);
            }
            
            // Suggestions
            console.log('\\n=== IMPROVEMENT SUGGESTIONS ===');
            if (winRate < 40) {
                console.log('‚ùå Low win rate - Consider:');
                console.log('  - Raising beta/momentum thresholds');
                console.log('  - Waiting for stronger entry signals');
                console.log('  - Improving exit timing');
            } else if (winRate > 60) {
                console.log('‚úÖ Good win rate!');
            }
            
            if (state.testResults.length === 0) {
                console.log('‚ö†Ô∏è No trades completed - cannot assess performance');
            } else if (avgPnl < 0) {
                console.log('‚ùå Losing money on average - Consider:');
                console.log('  - Taking profits earlier');
                console.log('  - Cutting losses faster');
                console.log('  - Only trading EXTREME signals');
            } else if (avgPnl > 0) {
                console.log('‚úÖ Profitable on average!');
            } else {
                console.log('‚ûñ Breaking even on average');
            }
            
            console.log('\\n=========================\\n');
        }

        // Save test results to file for AI analysis
        function saveTestResultsToFile() {
            if (!state.testResults || state.testResults.length === 0) return;
            
            const wins = state.testResults.filter(t => t.pnl > 0).length;
            const losses = state.testResults.filter(t => t.pnl < 0).length;
            const longs = state.testResults.filter(t => t.direction === 'long').length;
            const shorts = state.testResults.filter(t => t.direction === 'short').length;
            const totalPnl = state.testResults.reduce((sum, t) => sum + t.pnl, 0);
            const avgPnl = totalPnl / state.testResults.length;
            const winRate = (wins / state.testResults.length) * 100;
            
            const longTrades = state.testResults.filter(t => t.direction === 'long');
            const shortTrades = state.testResults.filter(t => t.direction === 'short').length;
            const exitReasons = {};
            state.testResults.forEach(t => {
                exitReasons[t.exitReason] = (exitReasons[t.exitReason] || 0) + 1;
            });
            
            const report = {
                timestamp: new Date().toISOString(),
                summary: {
                    totalTrades: state.testResults.length,
                    winRate: winRate.toFixed(1) + '%',
                    wins: wins,
                    losses: losses,
                    directions: { long: longs, short: shorts },
                    totalPnL: '$' + totalPnl.toFixed(2),
                    avgPnL: '$' + avgPnl.toFixed(2),
                    startBalance: '$' + state.testStartBalance.toFixed(2),
                    endBalance: '$' + state.balance.toFixed(2),
                    netChange: '$' + (state.balance - state.testStartBalance).toFixed(2)
                },
                performance: {
                    long: longTrades.length > 0 ? {
                        winRate: ((longTrades.filter(t => t.pnl > 0).length/longTrades.length)*100).toFixed(1) + '%',
                        totalPnL: '$' + longTrades.reduce((sum, t) => sum + t.pnl, 0).toFixed(2),
                        trades: longTrades.length
                    } : null,
                    short: shortTrades.length > 0 ? {
                        winRate: ((shortTrades.filter(t => t.pnl > 0).length/shortTrades.length)*100).toFixed(1) + '%',
                        totalPnL: '$' + shortTrades.reduce((sum, t) => sum + t.pnl, 0).toFixed(2),
                        trades: shortTrades.length
                    } : null
                },
                exitReasons: exitReasons,
                bestTrade: state.testResults.length > 0 ? {
                    symbol: [...state.testResults].sort((a, b) => b.pnl - a.pnl)[0].symbol,
                    pnl: '$' + [...state.testResults].sort((a, b) => b.pnl - a.pnl)[0].pnl.toFixed(2),
                    exitReason: [...state.testResults].sort((a, b) => b.pnl - a.pnl)[0].exitReason
                } : null,
                worstTrade: state.testResults.length > 0 ? {
                    symbol: [...state.testResults].sort((a, b) => a.pnl - b.pnl)[0].symbol,
                    pnl: '$' + [...state.testResults].sort((a, b) => a.pnl - b.pnl)[0].pnl.toFixed(2),
                    exitReason: [...state.testResults].sort((a, b) => a.pnl - b.pnl)[0].exitReason
                } : null,
                allTrades: state.testResults.map(t => ({
                    symbol: t.symbol,
                    direction: t.direction,
                    entryPrice: t.entryPrice,
                    exitPrice: t.exitPrice,
                    pnl: '$' + t.pnl.toFixed(2),
                    exitReason: t.exitReason,
                    holdTime: t.holdTime ? (t.holdTime/1000).toFixed(1) + 's' : 'N/A'
                }))
            };
            
            // Display summary in console
            console.log('üìä AUTO-SAVED TEST RESULTS');
            console.log(JSON.stringify(report.summary, null, 2));
            
            // Download JSON file
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `scalper-test-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('üíæ Saved to downloads: scalper-test-' + Date.now() + '.json');
        }

        // =============================================
        // INITIALIZATION
        // =============================================
        async function init() {
            loadState();
            updateStats();
            updateLearningProgress();
            renderHistory();

            if (state.autoMode) {
                el.autoToggle.classList.add('active');
                el.autoStatus.textContent = 'ON';
            }

            // Connect to price feed
            try {
                el.connText.textContent = 'Connecting...';
                await hyperliquidPriceFeed.connect();
                
                state.connected = true;
                el.connDot.classList.add('connected');
                
                // Check if WebSocket or REST
                const isWebSocket = hyperliquidPriceFeed.constructor.name === 'HyperliquidPriceFeed';
                el.connText.textContent = isWebSocket ? 'Live (WebSocket)' : 'Live (REST)';
                if (isWebSocket) {
                    console.log('üöÄ REAL-TIME WebSocket connection active - millisecond updates!');
                }

                // Start update loops
                setInterval(() => {
                    // Update volatility for all prices
                    const prices = hyperliquidPriceFeed.getAllPrices();
                    for (const [symbol, price] of Object.entries(prices)) {
                        updateVolatility(symbol, price);
                    }
                    renderScanner();
                }, config.pollingRate);

                // Trade display update (VERY fast for real-time)
                setInterval(() => {
                    if (state.inTrade) {
                        updateTradeDisplay();
                    }
                }, 10); // 10ms updates for instant visual feedback

            } catch (error) {
                el.connText.textContent = 'Error - Retrying...';
                console.error('Connection failed:', error);
                setTimeout(init, 5000);
            }
        }

        // Start
        init();
    </script>
    
    <style>
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
    </style>
</body>
</html>
